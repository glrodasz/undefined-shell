---
title: "What do I need to know before programming?"
pubDate: "2025-07-24T00:00:00.000Z"
tags: [Learn to program]
description: "Before starting to program, you don't need to be a genius or memorize formulas; just follow three pillars that simplify the path: learn to read documentation, review high school math, and maintain endless curiosity to adapt to constant technological changes. Let's see why, with these foundations, anyone can take their first steps with confidence."
heroImage: "/covers/vintage-wooden-toolbox-with-metal-wrenches.jpg"
languageVersions:
  - language: "es"
    url: "/es/posts/que-necesitas-saber-antes-de-programar"
---

Before starting to program, you don't need to be a genius or memorize formulas; just follow three pillars that simplify the path:

1. Learn to read documentation.
2. Review high school math.
3. Maintain endless curiosity to adapt to constant technological changes.

Let's see why, with these foundations, anyone can take their first steps with confidence.

## Reading... yes, but not just for the reason you think!
Throughout your career you'll spend approximately **90% of your time[^1] reading code, not writing it.** Good programmers:
* Read documentation
* Read code from other programmers.
* Read code from libraries and open source projects.
* Read their own code to make sure it doesn't have errors.

> ‚ÑπÔ∏è **Open Source**: is source code that is publicly available to be studied and that, in addition, can almost always be modified and redistributed. But, this depends on the license, since not all open source licenses grant those rights by default.

Personally, one of my favorite recommendations for learning to program is what I call **the art of reading code documentation**. It's not always simple, and that's why we content creators exist. Our purpose is usually to translate that information into more digestible formats, such as tutorials, videos, or books.

However, I confess that sometimes reading can be tedious, especially when I don't have some clear foundations. It's very tempting, even pleasant, to jump straight to typing code like a maniac. But on more than one occasion I've discovered, halfway through or even at the end, that my solution, although it "worked," didn't meet the requirements.

That's why **reading requirements** is also a vital skill for the professional developer.

> ‚ÑπÔ∏è **Requirements:** set of conditions and functionalities that an application must meet to satisfy the needs of the client or end user. This is what is commonly known as "ticket or task description," speaking in a very simplified way.

The good news is that if you're reading this blog, it's because you're one of those people who is willing to read to improve their professional future, so you're on the right track! üöÄ

## Basic math... but not so basic
I'd like to tell you that to program it's enough to know **addition, subtraction, multiplication, and division**, but in reality you need **a little bit more** than that.

> üß† Technically, **yes**, basic operations could be enough for very specific tasks like, for example, "layout," but... quickly, in technical tests or complex functionalities, you're going to need some extra mathematical operators.

> ‚ÑπÔ∏è **Layout** means translating user interface designs into code. On the web, HTML, CSS, and a pinch of JavaScript would be used, so imperative code is minimal (see more in [Types of programming languages](/posts/types-of-programming-languages/)).

You don't need to be a math expert or a quantum physicist. The **average programmer** in the commercial industry uses a very limited amount of math, practically what was learned in **secondary education**, with some exceptions. Let's see what areas it's good to review (no need to master them thoroughly or have them fresh before starting to program):

> ‚ö†Ô∏è If you program as a researcher or you're on the academic path, the situation changes. But if that's your case, I doubt that advanced math would be a problem for you.

### Elementary arithmetic
Operations of addition, subtraction, multiplication, and division. They are applied constantly, some examples are: calculating totals in a shopping cart, applying taxes, or handling quantities in business logic. It's also key to understand the **order of operations** in more complex expressions (knowing when multiplication is performed before addition, etc.).

### Percentages and proportions
It's useful to know how to calculate percentages, whether to determine discounts ("20% less in an offer") or for responsive design in frontend (for example, indicating that an element occupies 80% of the screen width). Understanding proportions helps distribute spaces and interpret metrics (like conversion rates).

### Basic algebra
Understanding variables and simple formulas. Although you rarely solve equations manually, you use **elementary algebra implicitly** when combining variables in code (e.g., calculating a value from two others). Knowing how to solve simple unknowns is useful for implementing business rules.

### Number systems and notation
It's beneficial to know the representation of numbers in **decimal, binary, and hexadecimal**. In the web world, they are used when working with colors in CSS (#FF5733 is the hexadecimal value of a reddish color), when manipulating bits for logical flags, or when understanding character codes. They are basic concepts of discrete mathematics that are normally learned in context, that is, as you learn to program.

### Basic geometry
In certain frontend cases, simple notions are required: understanding the **Cartesian coordinate system** to position elements (point 0,0 is usually in the upper left corner; `x` grows to the right, and `y` downward). In animations or 2D maps, the **Pythagorean theorem** or other simple formulas may appear, although it's not common in daily life, but rather sporadic, so knowing they exist is more than enough.

### Logical thinking
Beyond arithmetic, there are branches like formal logic, set theory, or statistics that **are not explicitly required** for an average web developer, but their concepts exist **implicitly** in programming and can be learned on the go. Let's see in what ways they usually appear:

#### Formal and boolean logic
Programming is based on logic, but you don't need to write truth tables on paper. It's enough to understand *true/false*, conjunctions, and disjunctions.

#### Set theory
It appears indirectly, especially when working with **databases**. SQL relies on *relational algebra* (an application of set theory) to join tables, intersect results, or select rows that meet certain conditions.

#### Statistics and probability
In standard web development, advanced statistics is **very limited**. A programmer focused on forms, APIs, or frontend rarely calculates statistical distributions or performs hypothesis tests in their code.

> üö® If at this point you're getting scared, don't worry. As I mentioned at the beginning, **you don't need to master all this before learning to program**. If you already know it, perfect; if not, you'll learn it when you need it.

## A lot, but a lot of curiosity
If you're one of those people who strive to understand **how things work** from their foundations, it's very possible that programming is for you, and moreover, your career can be very successful.

Technology advances so fast that everything changes all the time. However, the foundations create **solid bases** that make us more resistant and facilitate our adaptation to change.

Those of us who are curious usually explore those foundations almost by inertia, but changes can come suddenly. That's why it never hurts to reinforce the foundations: they usually remain relevant for a long time.

### Technology advances faster than it suits us
In more than a decade of programming, I've changed code editors more than ten times, I'll highlight some: Notepad, Notepad++, Eclipse, NetBeans, IntelliJ, Atom, VS Code, Cursor‚Ä¶

I've worked on all operating systems writing code: Windows, macOS, and Linux (various distributions).

I've written professionally in **six languages** (PHP, SQL, Java, JavaScript, TypeScript, and Python) and I've created small projects with a dozen more.

Frameworks, libraries, and work methodologies would form an immense list, but for the curious, I usually mention what's relevant in my [resume](https://vitae.guillermorodas.com).

Although many of these changes were personal decisions or preferences, most responded to what was most convenient for my career to stay "up to date."

Other changes were almost forced to maintain a competitive advantage: switching to Cursor, an AI editor, or to TypeScript, because in large teams it became essential to have a typed language and it's the most popular flavor of JavaScript.

### Change is not only at the technological level
Being an industry that changes so fast, many developers also change and switch jobs every 1 to 3 years. You'll have to adapt to new teams, restructurings, and policies (the famous *red tape*!), especially when startups grow very fast.

> ‚ÑπÔ∏è Laws also demand changes: *habeas data*, cookies, GDPR, or international security standards like DORA in Europe, among other regulations in the U.S.

### Change can come from third parties
Sometimes, a company modifies its pricing model and triggers a domino effect; that happened with **Heroku** and **Mandrill** when they eliminated their free plans. Many of us had to migrate production applications in a matter of days.

There are companies that go bankrupt and their products disappear. For example, **Parse** closed in 2017[^2], forcing thousands of mobile apps to look for alternatives. And if you don't know what problem they solved, it's hard to choose a good replacement.

Other times, due to protests or malicious actions, someone removes a library from the ecosystem, as in the famous case of **left-pad** (2016)[^3], which redefined how packages are managed in NPM.

## If you ask me, you don't need much
Although I've mentioned several points here, **I wouldn't consider them requirements**. In reality, the only indispensable condition is **the desire to learn**. That motivation will force you to read a lot, which, in turn, will awaken your **curiosity** to understand how the foundations of programming and computing work. Over time, these practices will allow you to **adapt to change**, something vital in an industry that advances so fast.

This blog focuses precisely on those foundations and the fundamentals of JavaScript. While the language remains alive (and it will only stop being so if JavaScript "dies" üòâ), what you learn here will help you keep advancing and feed your desire to learn.

> üçé **COBOL**, one of the oldest languages, has been around for 65 years; **PHP** has been "killed" for 25 years. **JavaScript** is the language of the web: without a doubt it has, at minimum, between 2 and 5 decades of life left... more than enough to finish this blog.

[^1]: Robert C. Martin, *Clean Code* (Spanish translation of *Clean Code*, 2008)
[^2]: Facebook's Parse developer platform is shutting down today - https://techcrunch.com/2017/01/30/facebooks-parse-developer-platform-is-shutting-down-today/
[^3]: kik, left-pad, and npm - https://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm
